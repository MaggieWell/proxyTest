# proxyTest
尝试研究代理模式写的小测试类
@[TOC](深度分析代理模式)

# 深度分析代理模式

1. 掌握代理模式的应用场景
2. 了解静态代理和动态代理的区别
3. 了解CGLib和JDK Proxy的根本区别
4. 简单实现定义的动态代理

## 内容定位

- 都知道SpringAOP时用代理模式实现，到底是怎么实现的呢？
- 自己仿真手写还原部分细节

## 代理模式的定义

> 代理模式(Proxy Pattern)是指为其他对象提供一种代理，以控制对这个对象的访问。
>
> 代理对象在客户端和目标对象之间起到中介作用。
>
> 属于结构型设计模式

## 生活中的代理模式

- 房产中介
- 快递小哥
- 黄牛党

## 代理模式的使用场景

- 保护目标对象
- 增强目标对象



## 静态代理

- 显式声明被代理对象

eg数据源路由：动态切换数据源

### 缺陷

> 不符合开闭原则，只要被代理的那个类需要新的代理，都需要在代理类中新加方法



## 动态代理

> 定义：动态配置和替换被代理对象

## JDK动态代理(```$Proxy0```)

1. 拿到被代理类的引用，并且获取他所有的接口（反射获取）需要实现接口；
2. JDK Proxy类重新生成新的类，实现了被代理类所有接口的方法；
3. 动态生成Java代码，把增强逻辑加入到新生成的代码中；
4. 编译生成新的java代码的class文件；
5. 加载并重新运行新的class，得到的类就是全新的类。

> ```Proxy```是一个用来生成新的代理类的工具类



![](https://img2018.cnblogs.com/blog/1064870/201905/1064870-20190526162346757-919340106.png)

> 一个问题：为什么这个类的接口的长度不能大于65535？

## 自己尝试写一个类似的Proxy生成代码

![](https://img2018.cnblogs.com/blog/1064870/201905/1064870-20190527114408196-1178287806.png)





## CGlib动态代理

1. JDK动态代理式是实现了被代理对象的接口，CGLib是继承了被代理对象；
2. JDK和CGLib都是在运行期生成字节码，JDK是直接写Class字节码，CGLib使用ASM框架写Class字节码，CGLib代理实现更复杂，生成代理类比JDK效率低；
3. JDK代用代理方法，是通过发射机制调用，CGLib是通过FastClass机制直接调用方法，CGLib执行效率更高。



1. CGLib代理的目标对象不需要实现任何接口，他是通过，动态继承目标对象实现的动态代理。

可看下图中模拟的CGLib的类

### 缺点

> 无法代理```final```修饰的方法

## 模拟CGLib实现的一个动态代理的类

- 动态实现Girl的findLove方法，并在其前后增加一些方法

![](https://img2018.cnblogs.com/blog/1064870/201905/1064870-20190527124454945-1646848635.png)

## 代理模式的优点

- 代理模式能将代理对象与真实被调用的目标对象分离；
- 一定程度上降低了系统的耦合程度，易于扩展；
- 代理可以起到把偶对象的作用；
- 增强目标对象的职责。

## 代理模式的缺点

- 代理模式会造成系统设计中类的数目增加
- 在客户端和目标对象之间增加了一个代理对象，会造成庆祝处理速度变慢。
- 增加了系统的复杂性。

## Spring中的代理模式以及其选择原则

> Spring的这一块没有仔细研究，后续会有专门Spring动态代理的内容。

![](https://img2018.cnblogs.com/blog/1064870/201905/1064870-20190527130320446-1623928907.png)

- 当Bean有实现接口时，Spring就会用JDK的动态代理

- 当Bean没有实现接口时，Spring就会选择CGLib

- Spring可以通过配置强制使用CGLib，只需要在Spring的配置文件中加入如下代码

  ```xml
  <aop:aspectj-autoproxy proxy-target-class="true"/>
  ```

参考资料：https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html



## 静态代理和动态的本质区别

1. 静态代理只能通过手动完成代理操作，如果被代理类增加新的方法，代理类需要同步
   新增，违背开闭原则。
2. 动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开
   闭原则。
3. 若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类便可完成，
   无需修改代理类的代码。

## 代理模式的优缺点

使用代理模式具有以下几个优点：

1. 代理模式能将代理对象与真实被调用的目标对象分离。
2. 一定程度上降低了系统的耦合度，扩展性好。
3. 可以起到保护目标对象的作用。
4. 可以对目标对象的功能增强。

当然，代理模式也是有缺点的：

1. 代理模式会造成系统设计中类的数量增加。
2. 在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。
3. 增加了系统的复杂度。
